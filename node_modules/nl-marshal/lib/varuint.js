"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const ISerializer_1 = __importDefault(require("./ISerializer"));
class VarUIntSerializer extends ISerializer_1.default {
    static validateBN(value) {
        if (!(value instanceof bignumber_js_1.default))
            throw new Error('invalid value type');
        if (!value.isFinite())
            throw new Error("value is not finite");
        if (!value.isInteger())
            throw new Error('value is not a integer');
        if (value.lt(0))
            throw new Error('value is negative');
    }
    toJSON(value) {
        if (typeof value === 'number') {
            if (Math.abs(value) > Number.MAX_SAFE_INTEGER)
                throw new Error('loss of accuracy');
            value = new bignumber_js_1.default(value);
        }
        else if (typeof value === 'string')
            value = new bignumber_js_1.default(value);
        VarUIntSerializer.validateBN(value);
        return value.gte(Number.MAX_SAFE_INTEGER) ? value.toString(10) : value.toNumber();
    }
    fromJSON(value) {
        const result = new bignumber_js_1.default(value);
        VarUIntSerializer.validateBN(result);
        return result;
    }
    toBuffer(value) {
        let bn = typeof value === 'string' || typeof value === 'number' ? new bignumber_js_1.default(value) : value;
        VarUIntSerializer.validateBN(bn);
        let resHex = '';
        let lastByte = true;
        do {
            const mod = bn.mod(Math.pow(2, 7));
            bn = bn.idiv(Math.pow(2, 7));
            const byte = lastByte ? mod.plus(Math.pow(2, 7)) : mod;
            lastByte = false;
            resHex = byte.toString(16).padStart(2, '0') + resHex;
        } while (bn.gt(0));
        return Buffer.from(resHex, 'hex');
    }
    readFromBuffer(buffer, offset = 0) {
        let res = new bignumber_js_1.default(0);
        while (true) {
            if (offset >= buffer.length)
                throw new Error(`overflow ${buffer.toString('hex')} ${offset}`);
            const byte = buffer[offset];
            offset += 1;
            const mod = byte % Math.pow(2, 7);
            res = res.times(Math.pow(2, 7)).plus(mod);
            if (byte >= Math.pow(2, 7))
                return { res, newOffset: offset };
        }
    }
}
exports.VarUIntSerializer = VarUIntSerializer;
const varuint = new VarUIntSerializer();
exports.default = varuint;
