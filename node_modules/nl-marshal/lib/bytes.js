"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = require("assert");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const bs58 = __importStar(require("bs58"));
const ISerializer_1 = __importDefault(require("./ISerializer"));
const varuint_1 = __importDefault(require("./varuint"));
var Encoding;
(function (Encoding) {
    Encoding["UTF_8"] = "utf-8";
    Encoding["BASE_58"] = "base58";
})(Encoding = exports.Encoding || (exports.Encoding = {}));
class BytesSerializer extends ISerializer_1.default {
    constructor(opts = {}) {
        super();
        this.encoding = opts.encoding === undefined ? Encoding.UTF_8 : opts.encoding;
        if (opts.length !== undefined) {
            assert_1.ok(opts.length >= 0);
            assert_1.ok(Number.isInteger(opts.length));
            assert_1.ok(opts.length <= Number.MAX_SAFE_INTEGER);
        }
        this.length = opts.length;
    }
    toJSON(value) {
        if (typeof value === "string")
            value = this.decode(value);
        if (this.length !== undefined)
            assert_1.ok(value.length === this.length);
        return this.encode(value);
    }
    fromJSON(value) {
        const result = this.decode(value);
        if (this.length !== undefined)
            assert_1.ok(result.length === this.length);
        return result;
    }
    toBuffer(value) {
        if (typeof value === "string")
            value = this.decode(value);
        if (this.length === undefined)
            return Buffer.concat([varuint_1.default.toBuffer(value.length), value]);
        assert_1.ok(value.length === this.length);
        return value;
    }
    readFromBuffer(buffer, offset = 0) {
        const { res: lengthBN, newOffset: from } = this.length === undefined ? varuint_1.default.readFromBuffer(buffer, offset) :
            { res: new bignumber_js_1.default(this.length), newOffset: offset };
        assert_1.ok(lengthBN.lte(Number.MAX_SAFE_INTEGER));
        const length = lengthBN.toNumber();
        assert_1.ok(buffer.length >= from + length);
        const newOffset = from + length;
        return { res: buffer.slice(from, newOffset), newOffset };
    }
    decode(str) {
        switch (this.encoding) {
            case Encoding.UTF_8: return Buffer.from(str, "utf-8");
            case Encoding.BASE_58: return bs58.decode(str);
            default: throw new Error(`decoding ${this.encoding} is not implemented`);
        }
    }
    encode(buffer) {
        switch (this.encoding) {
            case Encoding.UTF_8: return buffer.toString();
            case Encoding.BASE_58: return bs58.encode(buffer);
            default: throw new Error(`encoding ${this.encoding} is not implemented`);
        }
    }
}
exports.BytesSerializer = BytesSerializer;
function bytes(opts) {
    return new BytesSerializer(opts);
}
exports.default = bytes;
